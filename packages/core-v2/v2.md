# Bloom Core V2

> Rebuilding Bloom from the ground up with event-driven architecture, framework-agnostic adapters, and better developer experience.

Date: October 2025
Status: Active Development

---

## What We Have

Current implementation in `packages/core-v2/`:

- Package configuration (tsconfig.json, tsconfig.build.json, vitest.config.ts, package.json)
- Environment configuration (.env, .env.example)
- Zod v4 schemas with metadata
  - User, Session (api.ts)
  - Storage types (storage.ts) - CreateUserData, UpdateUserData, CreateSessionData
  - API method params (api.ts)
  - Session cookie parsing (session.ts)
  - Error handling (errors.ts)
- Utilities
  - Cookie parsing, serialization, creation (cookies.ts)
  - Crypto operations - argon2id hashing, token generation, email normalization (crypto.ts)
  - Framework-agnostic headers - supports 8 frameworks (headers.ts)
- Database adapter interface (storage/adapter.ts)
- Database adapters
  - Drizzle adapter (adapters/drizzle/) - supports SQLite, PostgreSQL, MySQL with type-safe schema
  - Kysely adapter (adapters/kysely/) - SQL query builder with type safety
  - Prisma adapter (adapters/prisma/) - modern ORM with schema migrations
  - MongoDB adapter (adapters/mongodb/) - NoSQL document database
- Storage implementations
  - Memory storage (storage/memory.ts) - for dev and traditional servers
  - Redis storage (storage/redis.ts) - for production with keyPrefix and defaultTTL
- Event system (events/emitter.ts)
  - String-based events with colon notation (user:created, session:found)
  - Wildcard pattern support (user:*, *:created, *)
  - on/emit/off methods with async handler support
  - Session lifecycle events (session:loading, session:found, session:accessed, session:notfound)
- Basic auth instance (auth.ts) with event integration
- 94 passing tests across 11 files (including event system and Redis integration tests)

---

## What We Don't Have

Missing pieces (in build order):

- Handler architecture (Request → Response pattern)
- API routes (register, login, logout, etc.)
- Rate limiting
- Session management endpoints
- Plugin system (builds on event system)
- Client library (React, Vue, Svelte)

---

## Architecture Vision

### Event System

Event-driven architecture for lifecycle hooks and plugin communication. Dynamic string-based events with wildcard pattern support.

Configuration:
```typescript
export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  events: {
    'user:created': async (user) => {
      await sendWelcomeEmail(user.email)
    },
    'session:found': async ({ user, session }) => {
      console.log('User session loaded:', user.email)
    },
    'user:*': async (data) => {
      // Listen to all user events
      await logUserActivity(data)
    },
  },
})
```

Runtime registration:
```typescript
// Register events after auth initialization
auth.on('user:login', async (user) => {
  await trackLogin(user.id)
})

// Emit custom events
await auth.emit('payment:completed', {
  userId: '123',
  amount: 99.99,
})

// Remove event listeners
auth.off('user:login', handler)
```

Wildcard patterns:
```typescript
auth.on('user:*', handler)        // All user events
auth.on('*:created', handler)     // All created events
auth.on('*', handler)             // All events
```

Built-in session events:
- `session:loading` - Session lookup started
- `session:found` - Session successfully loaded
- `session:accessed` - Session last_accessed updated
- `session:notfound` - Session lookup failed

### Handler Architecture

Core handler built directly in src/core/ using Web Standard Request/Response API. This is the foundation - framework adapters are thin wrappers that convert to Web Request.

Handler signature:
```typescript
export type BloomHandler = (request: Request) => Promise<Response>
```

Implementation approach:
- Built incrementally in packages/core-v2/src/core/
- Not a separate adapter package
- Handles routing, endpoint matching, and request processing
- Framework adapters are lightweight conversions to Web Request

Framework integration examples:

Next.js App Router:
```typescript
// app/api/auth/[...auth]/route.ts
import { auth } from '@/auth'
import { toWebRequest } from '@bloom/core-v2/nextjs'

export async function GET(req: Request) {
  return auth.handler(toWebRequest(req))
}

export async function POST(req: Request) {
  return auth.handler(toWebRequest(req))
}
```

Express:
```typescript
import { auth } from './auth'
import { toWebRequest } from '@bloom/core-v2/express'

app.all('/api/auth/*', async (req, res) => {
  const response = await auth.handler(toWebRequest(req))
  res.status(response.status).send(await response.text())
})
```

Standalone server (built into core):
```typescript
import { auth } from './auth'

// Server built into core package
auth.listen({ port: 3000 })
```

Request flow:
1. Framework request → Web Request (lightweight conversion)
2. Parse request (method, path, body, headers)
3. Run onRequest events
4. Match endpoint
5. Run before events
6. Execute endpoint
7. Run after events
8. Run onResponse events
9. Return Response

### Storage (Cache/Redis)

Optional storage for rate limiting, session cache, and temporary data. When not provided, features fall back to database or signed cookies.

Configuration:
```typescript
import { createClient } from 'redis'
import { redisStorage } from '@bloom/core/storage/redis'
import { memoryStorage } from '@bloom/core/storage/memory'

// Redis (production)
const redis = createClient({ url: process.env.REDIS_URL })
await redis.connect()

export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  storage: redisStorage(redis, {
    keyPrefix: 'bloom:',
    defaultTTL: 3600,
  }),
})

// Memory (dev + traditional servers)
export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  storage: memoryStorage(),
})

// No storage (production-safe)
export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  // Rate limiting uses database table
  // Session cache uses signed cookies
})
```

Available storage types:
- Redis - production standard (node-redis)
- Memory - dev and traditional servers (not serverless)
- Valkey - Redis fork (future)
- Memcached - simpler alternative (future)

Auto-detection:
- Has storage? Use for rate limiting and session cache
- No storage? Rate limiting uses database, session cache uses cookies
- Works everywhere (serverless, traditional, edge)

### Rate Limiting

Prevent abuse with configurable rate limits per endpoint. Storage automatically detected.

Configuration:
```typescript
const redis = createClient({ url: process.env.REDIS_URL })
await redis.connect()

export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  storage: redisStorage(redis, {
    keyPrefix: 'bloom:',
    defaultTTL: 3600,
  }),
  rateLimit: {
    window: 60,
    max: 100,
    customRules: {
      '/sign-in/email': { window: 10, max: 3 },
      '/two-factor/verify': { window: 10, max: 3 },
      '/get-session': false,
    },
  },
})
```

Storage strategies:
- Redis - fastest
- Database table - always works
- Memory - dev + traditional servers

Returns X-Retry-After header when limited.

### Session Caching

Reduce database queries with session caching.

Cookie cache:
```typescript
export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  session: {
    cookieCache: {
      maxAge: 300, // 5 minutes
    },
  },
})
```

With storage (faster):
```typescript
const redis = createClient({ url: process.env.REDIS_URL })
await redis.connect()

export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  storage: redisStorage(redis, {
    keyPrefix: 'bloom:',
    defaultTTL: 3600,
  }),
  session: {
    cookieCache: {
      maxAge: 300,
    },
  },
})
```

### Client Library

Framework-agnostic core with framework-specific bindings.

Core client:
```typescript
import { createAuthClient } from '@bloom/client'

export const client = createAuthClient({
  baseURL: 'http://localhost:3000',
})

const { data, error } = await client.signIn.email({
  email: 'test@example.com',
  password: 'password',
})
```

React hooks:
```typescript
import { createAuthClient } from '@bloom/react'

export const client = createAuthClient()

// In component
const { data: session, error, isPending, refetch } = client.useSession()
```

Vue composables:
```typescript
import { createAuthClient } from '@bloom/vue'

export const client = createAuthClient()

// In component
const session = client.useSession()
```

### Plugin System

Plugins extend Bloom functionality by registering themselves to fire based on event patterns. Built on top of the event system.

Plugin registration:
```typescript
export type BloomPlugin = {
  id: string
  events?: {
    matcher: (ctx: EventContext) => boolean
    handler: (ctx: EventContext) => Promise<void>
  }[]
  endpoints?: {
    path: string
    method: 'GET' | 'POST' | 'DELETE'
    handler: (req: Request) => Promise<Response>
  }[]
  schemas?: Record<string, ZodSchema>
  rateLimit?: Record<string, { window: number; max: number }>
}
```

Example - OAuth plugin:
```typescript
const oauthPlugin: BloomPlugin = {
  id: 'oauth',
  events: [
    {
      // Fire when user hits OAuth callback
      matcher: (ctx) => ctx.path.startsWith('/oauth/callback'),
      handler: async (ctx) => {
        const { provider, code } = ctx.query
        const tokens = await exchangeCodeForTokens(provider, code)
        ctx.context.tokens = tokens
      },
    },
  ],
  endpoints: [
    {
      path: '/oauth/:provider',
      method: 'GET',
      handler: async (req) => {
        const { provider } = req.params
        const authUrl = getAuthUrl(provider)
        return Response.redirect(authUrl)
      },
    },
  ],
  rateLimit: {
    '/oauth/:provider': { window: 60, max: 5 },
  },
}

export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  plugins: [oauthPlugin],
})
```

Pattern-based registration:
- Plugins use matchers to determine when to fire
- Can match on path, method, headers, query params
- Multiple plugins can respond to same event
- Execution order based on registration order

---

## Next Steps

Immediate priorities:

1. Database adapters
   - Completed: Drizzle, Kysely, Prisma, and MongoDB adapters
   - All adapters located in src/adapters/ with documentation
   - Next: Add integration tests with real databases

2. Build base server in src/core/
   - Create src/core/handler.ts (Web Request → Response)
   - Implement endpoint matching and routing
   - Build incrementally in core package (not separate adapters)
   - Start with basic handler that can process requests

3. Implement core API routes
   - POST /register - email/password registration
   - POST /login - email/password login
   - POST /logout - session termination
   - GET /session - current session retrieval
   - POST /verify-email - email verification
   - POST /request-password-reset - password reset request
   - POST /reset-password - password reset confirmation

4. Rate limiting with auto-detection
   - Database table fallback (rate_limit schema)
   - Storage support (Memory/Redis)
   - Per-path custom rules
   - X-Retry-After header

5. Session management endpoints
   - GET /sessions - list active sessions
   - DELETE /sessions/:id - revoke specific session
   - DELETE /sessions - revoke all sessions

6. Create plugin system
   - Define BloomPlugin type
   - Build on event system for plugin communication
   - Allow plugins to define schemas, events, rate limits
   - Create endpoint helper (createAuthEndpoint)

Secondary priorities:

- Session caching (cookie + storage)
- Additional storage adapters (Valkey, Memcached)
- Email templates and callbacks
- Client library (React, then Vue/Svelte)
- Documentation and examples

---

## Differences from Better Auth

Where we improve:

- Event system instead of hooks - clearer terminology, emphasizes reactive nature
- Simpler plugin API - less boilerplate
- Better TypeScript inference - leveraging Zod v4 metadata
- Framework-agnostic from the start - Web Standard Request/Response
- More flexible adapter system - not tied to Kysely
- Real-time event propagation - Convex-like reactivity for plugins

---

Last Updated: October 2025