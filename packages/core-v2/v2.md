# Bloom Core V2

> Rebuilding Bloom from the ground up with event-driven architecture, framework-agnostic adapters, and better developer experience.

Date: October 2025
Status: Active Development

---

## What We Have

Current implementation in `packages/core-v2/`:

- Package configuration (tsconfig.json, tsconfig.build.json, vitest.config.ts, package.json)
- Environment configuration (.env, .env.example)
- Zod v4 schemas with metadata
  - User, Session (api.ts)
  - Storage types (storage.ts) - CreateUserData, UpdateUserData, CreateSessionData
  - API method params (api.ts)
  - Session cookie parsing (session.ts)
  - Error handling (errors.ts)
- Utilities
  - Cookie parsing, serialization, creation (cookies.ts)
  - Crypto operations - argon2id hashing, token generation, email normalization (crypto.ts)
  - Framework-agnostic headers - supports 8 frameworks (headers.ts)
- Database adapter interface (storage/adapter.ts)
- Database adapters
  - Drizzle adapter (adapters/drizzle/) - supports SQLite, PostgreSQL, MySQL with type-safe schema
  - Kysely adapter (adapters/kysely/) - SQL query builder with type safety
  - Prisma adapter (adapters/prisma/) - modern ORM with schema migrations
  - MongoDB adapter (adapters/mongodb/) - NoSQL document database
- Storage implementations
  - Memory storage (storage/memory.ts) - for dev and traditional servers
  - Redis storage (storage/redis.ts) - for production with keyPrefix and defaultTTL
- Event system (events/emitter.ts)
  - String-based events with colon notation (user:created, session:found)
  - Wildcard pattern support (user:*, *:created, *)
  - on/emit/off methods with async handler support
  - Session lifecycle events (session:loading, session:found, session:accessed, session:notfound)
- Handler architecture (handler/)
  - Router system (router.ts) - route registration, path matching, parameter extraction, wildcard support
  - Context system (context.ts) - request context with method, path, query, headers, body, params, user, session
  - Universal handler (handler.ts) - Web Standard Request → Response with event integration
  - Request flow: parse → emit request:start → match route → emit endpoint:before → execute → emit endpoint:after → emit request:end → return response
- Auth instance (auth.ts) with handler, router, and event integration
  - Registered route: GET /session
  - handler method for Web Standard Request processing
  - router property for registering custom routes and plugins
- 109 passing tests across 12 files (including handler system, event system, and Redis integration tests)

---

## What We Don't Have

Missing pieces (in build order):

- API routes (register, login, logout, etc.)
- Rate limiting
- Session management endpoints
- Plugin system (builds on event system and handler)
- Framework adapters (Next.js, Express, etc.)
- Client library (React, Vue, Svelte)

---

## Architecture Vision

### Handler Architecture

Core handler built directly in src/handler/ using Web Standard Request/Response API. This is the foundation - framework adapters are thin wrappers that convert to Web Request.

Handler signature:
```typescript
export type BloomHandler = (request: Request) => Promise<Response>
```

Implementation approach:
- Built incrementally in packages/core-v2/src/handler/
- Not a separate adapter package
- Handles routing, endpoint matching, and request processing
- Framework adapters are lightweight conversions to Web Request

Framework integration examples:

Next.js App Router:
```typescript
// app/api/auth/[...auth]/route.ts
import { auth } from '@/auth'
import { toWebRequest } from '@bloom/core-v2/nextjs'

export async function GET(req: Request) {
  return auth.handler(toWebRequest(req))
}

export async function POST(req: Request) {
  return auth.handler(toWebRequest(req))
}
```

Express:
```typescript
import { auth } from './auth'
import { toWebRequest } from '@bloom/core-v2/express'

app.all('/api/auth/*', async (req, res) => {
  const response = await auth.handler(toWebRequest(req))
  res.status(response.status).send(await response.text())
})
```

Standalone server (built into core):
```typescript
import { auth } from './auth'

// Server built into core package
auth.listen({ port: 3000 })
```

Request flow:
1. Framework request → Web Request (lightweight conversion)
2. Parse request (method, path, body, headers)
3. Run onRequest events
4. Match endpoint
5. Run before events
6. Execute endpoint
7. Run after events
8. Run onResponse events
9. Return Response

### Storage (Cache/Redis)

Optional storage for rate limiting, session cache, and temporary data. When not provided, features fall back to database or signed cookies.

Configuration:
```typescript
import { createClient } from 'redis'
import { redisStorage } from '@bloom/core/storage/redis'
import { memoryStorage } from '@bloom/core/storage/memory'

// Redis (production)
const redis = createClient({ url: process.env.REDIS_URL })
await redis.connect()

export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  storage: redisStorage(redis, {
    keyPrefix: 'bloom:',
    defaultTTL: 3600,
  }),
})

// Memory (dev + traditional servers)
export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  storage: memoryStorage(),
})

// No storage (production-safe)
export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  // Rate limiting uses database table
  // Session cache uses signed cookies
})
```

Available storage types:
- Redis - production standard (node-redis)
- Memory - dev and traditional servers (not serverless)
- Valkey - Redis fork (future)
- Memcached - simpler alternative (future)

Auto-detection:
- Has storage? Use for rate limiting and session cache
- No storage? Rate limiting uses database, session cache uses cookies
- Works everywhere (serverless, traditional, edge)

### Rate Limiting

Prevent abuse with configurable rate limits per endpoint. Storage automatically detected.

Configuration:
```typescript
const redis = createClient({ url: process.env.REDIS_URL })
await redis.connect()

export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  storage: redisStorage(redis, {
    keyPrefix: 'bloom:',
    defaultTTL: 3600,
  }),
  rateLimit: {
    window: 60,
    max: 100,
    customRules: {
      '/sign-in/email': { window: 10, max: 3 },
      '/two-factor/verify': { window: 10, max: 3 },
      '/get-session': false,
    },
  },
})
```

Storage strategies:
- Redis - fastest
- Database table - always works
- Memory - dev + traditional servers

Returns X-Retry-After header when limited.

### Session Caching

Reduce database queries with session caching.

Cookie cache:
```typescript
export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  session: {
    cookieCache: {
      maxAge: 300, // 5 minutes
    },
  },
})
```

With storage (faster):
```typescript
const redis = createClient({ url: process.env.REDIS_URL })
await redis.connect()

export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  storage: redisStorage(redis, {
    keyPrefix: 'bloom:',
    defaultTTL: 3600,
  }),
  session: {
    cookieCache: {
      maxAge: 300,
    },
  },
})
```

### Client Library

Framework-agnostic core with framework-specific bindings.

Core client:
```typescript
import { createAuthClient } from '@bloom/client'

export const client = createAuthClient({
  baseURL: 'http://localhost:3000',
})

const { data, error } = await client.signIn.email({
  email: 'test@example.com',
  password: 'password',
})
```

React hooks:
```typescript
import { createAuthClient } from '@bloom/react'

export const client = createAuthClient()

// In component
const { data: session, error, isPending, refetch } = client.useSession()
```

Vue composables:
```typescript
import { createAuthClient } from '@bloom/vue'

export const client = createAuthClient()

// In component
const session = client.useSession()
```

### Plugin System

Plugins extend Bloom functionality by registering themselves to fire based on event patterns. Built on top of the event system.

Plugin registration:
```typescript
export type BloomPlugin = {
  id: string
  events?: {
    matcher: (ctx: EventContext) => boolean
    handler: (ctx: EventContext) => Promise<void>
  }[]
  endpoints?: {
    path: string
    method: 'GET' | 'POST' | 'DELETE'
    handler: (req: Request) => Promise<Response>
  }[]
  schemas?: Record<string, ZodSchema>
  rateLimit?: Record<string, { window: number; max: number }>
}
```

Example - OAuth plugin:
```typescript
const oauthPlugin: BloomPlugin = {
  id: 'oauth',
  events: [
    {
      // Fire when user hits OAuth callback
      matcher: (ctx) => ctx.path.startsWith('/oauth/callback'),
      handler: async (ctx) => {
        const { provider, code } = ctx.query
        const tokens = await exchangeCodeForTokens(provider, code)
        ctx.context.tokens = tokens
      },
    },
  ],
  endpoints: [
    {
      path: '/oauth/:provider',
      method: 'GET',
      handler: async (req) => {
        const { provider } = req.params
        const authUrl = getAuthUrl(provider)
        return Response.redirect(authUrl)
      },
    },
  ],
  rateLimit: {
    '/oauth/:provider': { window: 60, max: 5 },
  },
}

export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  plugins: [oauthPlugin],
})
```

Pattern-based registration:
- Plugins use matchers to determine when to fire
- Can match on path, method, headers, query params
- Multiple plugins can respond to same event
- Execution order based on registration order

---

## Next Steps

Immediate priorities:

1. Database adapters - COMPLETED
   - Drizzle, Kysely, Prisma, and MongoDB adapters
   - All adapters located in src/adapters/ with documentation
   - Next: Add integration tests with real databases

2. Handler architecture - COMPLETED
   - Router, Context, and Handler in src/core/
   - Web Standard Request → Response pattern implemented
   - Event integration throughout request lifecycle
   - 15 comprehensive tests covering all functionality

3. Implement core API routes
   - POST /register - email/password registration
   - POST /login - email/password login
   - POST /logout - session termination
   - GET /session - current session retrieval
   - POST /verify-email - email verification
   - POST /request-password-reset - password reset request
   - POST /reset-password - password reset confirmation

4. Rate limiting with auto-detection
   - Database table fallback (rate_limit schema)
   - Storage support (Memory/Redis)
   - Per-path custom rules
   - X-Retry-After header

5. Session management endpoints
   - GET /sessions - list active sessions
   - DELETE /sessions/:id - revoke specific session
   - DELETE /sessions - revoke all sessions

6. Framework adapters
   - Next.js adapter - toNextJsHandler({ auth }) returns { GET, POST, DELETE, OPTIONS }
   - Express adapter - converts Express req/res to Web Request/Response
   - Hono, Fastify, SvelteKit adapters - lightweight wrappers

7. Create plugin system
   - Define BloomPlugin type
   - Build on event system for plugin communication
   - Plugins register routes directly via router.register()
   - Allow plugins to define schemas, events, rate limits
   - Create endpoint helper (createAuthEndpoint)

Secondary priorities:

- Session caching (cookie + storage)
- Additional storage adapters (Valkey, Memcached)
- Email templates and callbacks
- Client library (React, then Vue/Svelte)
- Documentation and examples

---

## Differences from Better Auth

Where we improve:

- Event system instead of hooks - clearer terminology, emphasizes reactive nature
- Simpler plugin API - less boilerplate
- Better TypeScript inference - leveraging Zod v4 metadata
- Framework-agnostic from the start - Web Standard Request/Response
- More flexible adapter system - not tied to Kysely
- Real-time event propagation - Convex-like reactivity for plugins

---

Last Updated: October 2025