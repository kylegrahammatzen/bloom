# Bloom Core V2

> Rebuilding Bloom from the ground up with event-driven architecture, framework-agnostic adapters, and better developer experience.

Date: October 2025
Status: Active Development

---

## What We Have

Current implementation in `packages/core-v2/`:

- Package configuration (tsconfig.json, tsconfig.build.json, vitest.config.ts, package.json)
- Environment configuration (.env, .env.example)
- Zod v4 schemas with metadata
  - User, Session (api.ts)
  - Storage types (storage.ts) - CreateUserData, UpdateUserData, CreateSessionData
  - API method params (api.ts)
  - Session cookie parsing (session.ts)
  - Error handling (errors.ts)
- Utilities
  - Cookie parsing, serialization, creation (cookies.ts)
  - Crypto operations - argon2id hashing, token generation, email normalization (crypto.ts)
  - Framework-agnostic headers - supports 8 frameworks (headers.ts)
- Database adapter interface (storage/adapter.ts)
- Storage implementations
  - Memory storage (storage/memory.ts) - for dev and traditional servers
  - Redis storage (storage/redis.ts) - for production with keyPrefix and defaultTTL
- Basic auth instance (auth.ts)
- 74 passing tests across 10 files (including Redis integration tests)

---

## What We Don't Have

Missing pieces:

- Database adapters (Drizzle, Kysely, Prisma, MongoDB)
- Event system (before/after events, database events)
- Handler architecture (Request → Response pattern)
- Plugin system
- API routes (register, login, logout, etc.)
- Rate limiting
- Client library (React, Vue, Svelte)
- Session management endpoints

---

## Architecture Vision

### Database Adapters

Replace in-memory adapter with real database support. Support whatever users already have - no ORM lock-in.

Adapter interface:
```typescript
export type DatabaseAdapter = {
  user: {
    findById: (id: string) => Promise<User | null>
    findByEmail: (email: string) => Promise<User | null>
    create: (data: CreateUserData) => Promise<User>
    update: (id: string, data: UpdateUserData) => Promise<User>
    delete: (id: string) => Promise<void>
  }
  session: {
    findById: (id: string) => Promise<Session | null>
    findByUserId: (userId: string) => Promise<Session[]>
    create: (data: CreateSessionData) => Promise<Session>
    update: (id: string, data: Partial<CreateSessionData>) => Promise<Session>
    delete: (id: string) => Promise<void>
    deleteExpired: () => Promise<number>
  }
}
```

Adapters to support:
- Drizzle - for users with Drizzle ORM
- Kysely - for users with Kysely query builder
- Prisma - for users with Prisma ORM
- Direct connection - for users with mysql2, pg, better-sqlite3 pools
- MongoDB - for users with MongoDB driver

Each adapter has its own test suite and examples.

Drizzle example:
```typescript
import { drizzle } from 'drizzle-orm/better-sqlite3'
import Database from 'better-sqlite3'
import { drizzleAdapter } from '@bloom/core/adapters/drizzle'

const db = drizzle(new Database('db.sqlite'))

export const auth = bloomAuth({
  adapter: drizzleAdapter(db, { provider: 'sqlite' }),
})
```

Kysely example (or direct mysql2/pg):
```typescript
import { Kysely, MysqlDialect } from 'kysely'
import { createPool } from 'mysql2/promise'
import { kyselyAdapter } from '@bloom/core/adapters/kysely'

const db = new Kysely({
  dialect: new MysqlDialect({ pool: createPool({ host: 'localhost' }) }),
})

export const auth = bloomAuth({
  adapter: kyselyAdapter(db),
})
```

Prisma example:
```typescript
import { PrismaClient } from '@prisma/client'
import { prismaAdapter } from '@bloom/core/adapters/prisma'

const prisma = new PrismaClient()

export const auth = bloomAuth({
  adapter: prismaAdapter(prisma),
})
```

MongoDB example:
```typescript
import { MongoClient } from 'mongodb'
import { mongodbAdapter } from '@bloom/core/adapters/mongodb'

const client = new MongoClient('mongodb://localhost:27017')
const db = client.db('mydb')

export const auth = bloomAuth({
  adapter: mongodbAdapter(db, { client }),
})
```

### Event System

Event-driven architecture instead of callbacks. Call them "events" not "hooks" to differentiate from better-auth and emphasize reactive nature.

Types of events:
- Before events - run before operations, can modify or abort
- After events - run after operations, for side effects
- Database events - run before/after database operations

Event types:
```typescript
export type BeforeEvent = {
  matcher: (ctx: EventContext) => boolean
  handler: (ctx: EventContext) => Promise<{ context?: EventContext } | void>
}

export type AfterEvent = {
  matcher: (ctx: EventContext) => boolean
  handler: (ctx: EventContext) => Promise<void>
}

export type DatabaseEvents = {
  user?: {
    create?: {
      before?: (data: CreateUserData, ctx: EventContext) => Promise<{ data: CreateUserData } | false>
      after?: (user: User) => Promise<void>
    }
    update?: {
      before?: (id: string, data: UpdateUserData, ctx: EventContext) => Promise<{ data: UpdateUserData } | false>
      after?: (user: User) => Promise<void>
    }
  }
  session?: {
    // similar structure
  }
}
```

Usage example:
```typescript
export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  events: {
    after: [
      {
        matcher: (ctx) => ctx.path === '/sign-up/email',
        handler: async (ctx) => {
          const session = ctx.context.newSession
          await sendWelcomeEmail(session.user.email)
        },
      },
    ],
  },
  databaseEvents: {
    user: {
      create: {
        after: async (user) => {
          await stripe.customers.create({ email: user.email })
        },
      },
    },
  },
})
```

Events emitted:
- user.created
- user.updated
- user.deleted
- user.signedIn
- user.signedOut
- session.created
- session.updated
- session.revoked

### Handler Architecture

Core handler uses Web Standard Request/Response API.

Handler signature:
```typescript
export type BloomHandler = (request: Request) => Promise<Response>
```

Framework adapters convert framework-specific requests to Web Request:

Next.js App Router:
```typescript
// app/api/auth/[...auth]/route.ts
import { auth } from '@/auth'
import { createNextJSRoute } from '@bloom/adapters/nextjs'

export const { GET, POST } = createNextJSRoute(auth)
```

Next.js Pages Router:
```typescript
// pages/api/auth/[...auth].ts
import { auth } from '@/auth'
import { createNextJSPagesHandler } from '@bloom/adapters/nextjs/pages'

export default createNextJSPagesHandler(auth)
```

Express:
```typescript
import { auth } from './auth'
import { createExpressHandler } from '@bloom/adapters/express'

app.use('/api/auth', createExpressHandler(auth))
```

Standalone server:
```typescript
import { auth } from './auth'
import { createServer } from '@bloom/core/server'

createServer(auth, { port: 3000 })
```

Request flow:
1. Framework request → Web Request
2. Parse request (method, path, body, headers)
3. Run onRequest events
4. Match endpoint
5. Run before events
6. Execute endpoint
7. Run after events
8. Run onResponse events
9. Return Response

### Storage (Cache/Redis)

Optional high-speed storage for rate limiting, session cache, and temporary data. When not provided, features fall back to database or signed cookies.

Configuration:
```typescript
import { createClient } from 'redis'
import { redisStorage } from '@bloom/core/storage/redis'
import { memoryStorage } from '@bloom/core/storage/memory'

// Redis (production)
const redis = createClient({ url: process.env.REDIS_URL })
await redis.connect()

export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  storage: redisStorage(redis, {
    keyPrefix: 'bloom:',
    defaultTTL: 3600,
  }),
})

// Memory (dev + traditional servers)
export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  storage: memoryStorage(),
})

// No storage (production-safe)
export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  // Rate limiting uses database table
  // Session cache uses signed cookies
})
```

Available storage types:
- Redis - production standard (node-redis)
- Memory - dev and traditional servers (not serverless)
- Valkey - Redis fork (future)
- Memcached - simpler alternative (future)

Auto-detection:
- Has storage? Use for rate limiting and session cache
- No storage? Rate limiting uses database, session cache uses cookies
- Works everywhere (serverless, traditional, edge)

### Rate Limiting

Prevent abuse with configurable rate limits per endpoint. Storage automatically detected.

Configuration:
```typescript
const redis = createClient({ url: process.env.REDIS_URL })
await redis.connect()

export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  storage: redisStorage(redis, {
    keyPrefix: 'bloom:',
    defaultTTL: 3600,
  }),
  rateLimit: {
    window: 60,
    max: 100,
    customRules: {
      '/sign-in/email': { window: 10, max: 3 },
      '/two-factor/verify': { window: 10, max: 3 },
      '/get-session': false,
    },
  },
})
```

Storage strategies:
- Redis - fastest
- Database table - always works
- Memory - dev + traditional servers

Returns X-Retry-After header when limited.

### Session Caching

Reduce database queries with session caching.

Cookie cache:
```typescript
export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  session: {
    cookieCache: {
      maxAge: 300, // 5 minutes
    },
  },
})
```

With storage (faster):
```typescript
const redis = createClient({ url: process.env.REDIS_URL })
await redis.connect()

export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  storage: redisStorage(redis, {
    keyPrefix: 'bloom:',
    defaultTTL: 3600,
  }),
  session: {
    cookieCache: {
      maxAge: 300,
    },
  },
})
```

### Client Library

Framework-agnostic core with framework-specific bindings.

Core client:
```typescript
import { createAuthClient } from '@bloom/client'

export const client = createAuthClient({
  baseURL: 'http://localhost:3000',
})

const { data, error } = await client.signIn.email({
  email: 'test@example.com',
  password: 'password',
})
```

React hooks:
```typescript
import { createAuthClient } from '@bloom/react'

export const client = createAuthClient()

// In component
const { data: session, error, isPending, refetch } = client.useSession()
```

Vue composables:
```typescript
import { createAuthClient } from '@bloom/vue'

export const client = createAuthClient()

// In component
const session = client.useSession()
```

---

## Next Steps

Immediate priorities:

1. Implement database adapters
   - Start with Drizzle (SQLite first, then PostgreSQL/MySQL)
   - Each adapter in src/adapters/ with integration tests
   - Schema generation examples for each ORM
   - Test with real databases

2. Design event system
   - Create src/schemas/events.ts (BeforeEvent, AfterEvent, DatabaseEvents)
   - Implement event dispatcher in src/events/
   - Add to BloomAuth config

3. Build handler architecture
   - Create src/handler.ts (Request → Response)
   - Implement endpoint matching
   - Integrate event system into request flow
   - Framework adapters (Next.js, Express, etc.)

4. Create plugin system
   - Define BloomPlugin type
   - Implement plugin registration
   - Create endpoint helper (createAuthEndpoint)
   - Allow plugins to define schemas, events, rate limits

5. Implement core API routes
   - POST /register
   - POST /login
   - POST /logout
   - GET /session
   - POST /verify-email
   - POST /request-password-reset
   - POST /reset-password

6. Rate limiting with auto-detection
   - Database table fallback (rate_limit schema)
   - Storage support (Memory/Redis)
   - Per-path custom rules
   - X-Retry-After header

Secondary priorities:

- Kysely, Prisma, MongoDB adapters
- Session caching (cookie + storage)
- Additional storage adapters (Valkey, Memcached)
- Client library (React, then Vue/Svelte)
- Session management endpoints (list, revoke)
- Email templates and callbacks
- Documentation and examples

---

## Differences from Better Auth

Where we improve:

- Event system instead of hooks - clearer terminology, emphasizes reactive nature
- Simpler plugin API - less boilerplate
- Better TypeScript inference - leveraging Zod v4 metadata
- Framework-agnostic from the start - Web Standard Request/Response
- More flexible adapter system - not tied to Kysely
- Real-time event propagation - Convex-like reactivity for plugins

---

Last Updated: October 2025