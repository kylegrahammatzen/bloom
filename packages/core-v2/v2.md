# Bloom Core V2

> Rebuilding Bloom from the ground up with event-driven architecture, framework-agnostic adapters, and better developer experience.

Date: October 2025
Status: Active Development

---

## What We Have

Current implementation in `packages/core-v2/`:

- Package configuration (tsconfig.json, tsconfig.build.json, vitest.config.ts, package.json)
- Environment configuration (.env, .env.example)
- Zod v4 schemas with metadata
  - User, Session (api.ts)
  - Storage types (storage.ts) - CreateUserData, UpdateUserData, CreateSessionData
  - API method params (api.ts)
  - Session cookie parsing (session.ts)
  - Error handling (errors.ts)
- Utilities
  - Cookie parsing, serialization, creation (cookies.ts)
  - Crypto operations - argon2id hashing, token generation, email normalization (crypto.ts)
  - Framework-agnostic headers - supports 8 frameworks (headers.ts)
- Database adapter interface (storage/adapter.ts)
- Database adapters
  - Drizzle adapter (adapters/drizzle/) - supports SQLite, PostgreSQL, MySQL with type-safe schema
  - Kysely adapter (adapters/kysely/) - SQL query builder with type safety
  - Prisma adapter (adapters/prisma/) - modern ORM with schema migrations
  - MongoDB adapter (adapters/mongodb/) - NoSQL document database
- Storage implementations
  - Memory storage (storage/memory.ts) - for dev and traditional servers
  - Redis storage (storage/redis.ts) - for production with keyPrefix and defaultTTL
- Event system (events/emitter.ts)
  - String-based events with colon notation (user:created, session:found)
  - Wildcard pattern support (user:*, *:created, *)
  - on/emit/off methods with async handler support
  - Session lifecycle events (session:loading, session:found, session:accessed, session:notfound)
- Handler architecture (handler/)
  - Router system (router.ts) - route registration, path matching, parameter extraction, wildcard support
  - Context system (context.ts) - request context with method, path, query, headers, body, params, user, session
  - Universal handler (handler.ts) - Web Standard Request → Response with event integration
  - Request flow: parse → emit request:start → rate limit check → match route → emit endpoint:before → execute → emit endpoint:after → emit request:end → return response
- Rate limiting (rateLimit/)
  - Auto-detection: Storage → Database → Memory
  - Configurable per-path rules (exact, wildcard, function)
  - IP-based limiting with custom header detection
  - Zod-validated configuration
  - Returns 429 with X-RateLimit-* and X-Retry-After headers
  - Event emission on limit exceeded (ratelimit:exceeded)
  - Drizzle adapter support (optional rateLimits table)
- Auth instance (auth.ts) with handler, router, rate limiter, and event integration
  - Registered route: GET /session
  - handler method for Web Standard Request processing
  - router property for registering custom routes and plugins
  - rateLimiter for request throttling
- 124 passing tests across 13 files (including handler, rate limiting, event system, and Redis integration)

---

## What We Don't Have

Missing pieces (in build order):

- API routes (register, login, logout, etc.)
- Session management endpoints
- Plugin system (builds on event system and handler)
- Framework adapters (Next.js, Express, etc.)
- Client library (React, Vue, Svelte)

---

## Architecture Vision

### Session Caching

Reduce database queries with session caching.

Cookie cache:
```typescript
export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  session: {
    cookieCache: {
      maxAge: 300, // 5 minutes
    },
  },
})
```

With storage (faster):
```typescript
const redis = createClient({ url: process.env.REDIS_URL })
await redis.connect()

export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  storage: redisStorage(redis, {
    keyPrefix: 'bloom:',
    defaultTTL: 3600,
  }),
  session: {
    cookieCache: {
      maxAge: 300,
    },
  },
})
```

### Client Library

Framework-agnostic core with framework-specific bindings.

Core client:
```typescript
import { createAuthClient } from '@bloom/client'

export const client = createAuthClient({
  baseURL: 'http://localhost:3000',
})

const { data, error } = await client.signIn.email({
  email: 'test@example.com',
  password: 'password',
})
```

React hooks:
```typescript
import { createAuthClient } from '@bloom/react'

export const client = createAuthClient()

// In component
const { data: session, error, isPending, refetch } = client.useSession()
```

Vue composables:
```typescript
import { createAuthClient } from '@bloom/vue'

export const client = createAuthClient()

// In component
const session = client.useSession()
```

### Plugin System

Plugins extend Bloom functionality by registering themselves to fire based on event patterns. Built on top of the event system.

Plugin registration:
```typescript
export type BloomPlugin = {
  id: string
  events?: {
    matcher: (ctx: EventContext) => boolean
    handler: (ctx: EventContext) => Promise<void>
  }[]
  endpoints?: {
    path: string
    method: 'GET' | 'POST' | 'DELETE'
    handler: (req: Request) => Promise<Response>
  }[]
  schemas?: Record<string, ZodSchema>
  rateLimit?: Record<string, { window: number; max: number }>
}
```

Example - OAuth plugin:
```typescript
const oauthPlugin: BloomPlugin = {
  id: 'oauth',
  events: [
    {
      // Fire when user hits OAuth callback
      matcher: (ctx) => ctx.path.startsWith('/oauth/callback'),
      handler: async (ctx) => {
        const { provider, code } = ctx.query
        const tokens = await exchangeCodeForTokens(provider, code)
        ctx.context.tokens = tokens
      },
    },
  ],
  endpoints: [
    {
      path: '/oauth/:provider',
      method: 'GET',
      handler: async (req) => {
        const { provider } = req.params
        const authUrl = getAuthUrl(provider)
        return Response.redirect(authUrl)
      },
    },
  ],
  rateLimit: {
    '/oauth/:provider': { window: 60, max: 5 },
  },
}

export const auth = bloomAuth({
  adapter: drizzleAdapter(db),
  plugins: [oauthPlugin],
})
```

Pattern-based registration:
- Plugins use matchers to determine when to fire
- Can match on path, method, headers, query params
- Multiple plugins can respond to same event
- Execution order based on registration order

---

## Next Steps

Immediate priorities:

1. Database adapters - COMPLETED
   - Drizzle, Kysely, Prisma, and MongoDB adapters
   - All adapters located in src/adapters/ with documentation
   - Next: Add integration tests with real databases

2. Handler architecture - COMPLETED
   - Router, Context, and Handler in src/handler/
   - Web Standard Request → Response pattern implemented
   - Event integration throughout request lifecycle
   - 15 comprehensive tests covering all functionality

3. Rate limiting - COMPLETED
   - Auto-detection (Storage → Database → Memory)
   - Configurable per-path rules (exact, wildcard, function)
   - IP-based limiting with custom header detection
   - Returns 429 with X-RateLimit-* and X-Retry-After headers
   - 15 comprehensive tests
   - Drizzle adapter support

4. Implement core API routes
   - POST /register - email/password registration
   - POST /login - email/password login
   - POST /logout - session termination
   - GET /session - current session retrieval
   - POST /verify-email - email verification
   - POST /request-password-reset - password reset request
   - POST /reset-password - password reset confirmation

5. Session management endpoints
   - GET /sessions - list active sessions
   - DELETE /sessions/:id - revoke specific session
   - DELETE /sessions - revoke all sessions

6. Framework adapters
   - Next.js adapter - toNextJsHandler({ auth }) returns { GET, POST, DELETE, OPTIONS }
   - Express adapter - converts Express req/res to Web Request/Response
   - Hono, Fastify, SvelteKit adapters - lightweight wrappers

7. Create plugin system
   - Define BloomPlugin type
   - Build on event system for plugin communication
   - Plugins register routes directly via router.register()
   - Allow plugins to define schemas, events, rate limits
   - Create endpoint helper (createAuthEndpoint)

Secondary priorities:

- Session caching (cookie + storage)
- Additional storage adapters (Valkey, Memcached)
- Email templates and callbacks
- Client library (React, then Vue/Svelte)
- Documentation and examples

---

## Differences from Better Auth

Where we improve:

- Event system instead of hooks - clearer terminology, emphasizes reactive nature
- Simpler plugin API - less boilerplate
- Better TypeScript inference - leveraging Zod v4 metadata
- Framework-agnostic from the start - Web Standard Request/Response
- More flexible adapter system - not tied to Kysely
- Real-time event propagation - Convex-like reactivity for plugins

---

Last Updated: October 2025